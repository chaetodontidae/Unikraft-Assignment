# ELF 动态链接

### 程序解释器

参与动态链接的ELF文件应该具备 `PT_INTERP`程序头。在exec中，系统从`PT_INTERP`段获取路径名并且为解释器文件段创建初始的进程镜像。之后解释器需要接管运行流程并且为应用程序提供运行环境。

解释器可以选择两种方式中的一种接管程序：

- 接受文件描述符以读取可执行文件，从文件开头开始。可以将文件的段通过读取或者映射的方式加载入内存。
- 加载可执行文件的操作由系统完成（能不能使用由可执行文件的格式决定），解释器初始化进程的状态与可执行文件中的描述一致。这种方式下解释器一般不会需要加载二层解释器，解释器可以是shared object或者executable file

此处对shared object与executable file进行一个简要的介绍：

- shared object：以position-independent方式加载，在不同进程运行的地址不同。系统通过mmap或相关服务动态映射段位置。因此shared object解释器一般不会与原来的可执行文件的段地址产生冲突
- 可执行文件可能需要被加载到固定位置，系统通过虚拟地址映射的方式创建段。这种方式可能与原来的可执行文件产生冲突，解释器需要负责处理这种冲突

### 动态链接器

创建动态链接的可执行文件时，连接器会向程序头添加`PT_INTERP`头，使得系统调用动态链接器作为程序的解释器

一般的协作流程如下：

- 将可执行文件的内存段加载入进程映像
- 向进程镜像添加shared object内存段
- 为可执行文件与shared objects 进行重定向
- 关闭可执行文件的进程描述符
- 向程序转移控制权，使得程序像是通过exec系统调用获得控制权

Linker会创建不同的数据类型协助executable and shared objects

- SHT_DYNAMIC类型的.dynamic段维护动态链接相关的地址与其他信息
- SHT_HASH类型的.hash段维护符号哈希表信息
- SHT_PROGBITS类型的.got与.plt段维护两个表：全局偏移表与链接创建表

ABI基础的程序需要通过shared objects库导入基本服务，动态链接器将会参与到所有ABI基础的程序

由于真实的加载地址通常与文件中的记录存在出入，动态链接器需要在执行程序前对内存镜像进行重定位，更新绝对地址。可以通过设置LD_BIND_NOW控制该行为。也可以通过懒处理方式在执行函数前处理，以此省去未使用函数不必要的重定向解析开销。



